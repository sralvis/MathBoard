<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MathBoard</title>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Axios -->
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <!-- MathLive -->
    <script src="//unpkg.com/mathlive"></script>

    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
            'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
            sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow: hidden;
        }

        .App {
            width: 100vw;
            height: 100vh;
        }

        .canvas {
            width: 100%;
            height: 100%;
            position: relative;
            background-image: linear-gradient(#ddd 1px, transparent 1px), linear-gradient(90deg, #ddd 1px, transparent 1px);
            background-size: 20px 20px;
            background-color: #fff;
        }

        .region-container:hover {
            border: 1px dashed #ccc !important;
        }
        .region-container:hover .handle {
            display: block !important;
        }

        math-field {
            font-size: 1.2em;
            background: transparent;
            border: none;
            outline: none;
        }

        math-field:focus-within {
            outline: none;
            background: rgba(0, 0, 0, 0.02);
        }

        .toolbar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .toolbar button {
            background: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 5px 10px;
            cursor: pointer;
            font-family: monospace;
            font-size: 1.1em;
        }

        .toolbar button:hover {
            background: #e0e0e0;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        // Custom Hook for Debounce
        function useDebounce(value, delay) {
            const [debouncedValue, setDebouncedValue] = useState(value);
            useEffect(() => {
                const handler = setTimeout(() => {
                    setDebouncedValue(value);
                }, delay);
                return () => {
                    clearTimeout(handler);
                };
            }, [value, delay]);
            return debouncedValue;
        }

        const MathRegion = ({ content, onContentChange, result, isActive, onFocus }) => {
            const mfRef = useRef(null);

            // Sync content TO MathLive
            useEffect(() => {
                if (mfRef.current && mfRef.current.value !== content) {
                     // Only update if significantly different to avoid cursor jumping
                     // MathLive value usually normalizes LaTeX, so simple strict equality check is okay for now
                     mfRef.current.value = content;
                }
            }, [content]);

            const handleInput = (e) => {
                // Avoid infinite loop if the value is effectively the same
                if (content !== e.target.value) {
                    onContentChange(e.target.value);
                }
            };

            return (
                <div
                    className="math-region"
                    style={{ display: 'flex', alignItems: 'center' }}
                    onClick={onFocus}
                >
                    <math-field
                        ref={mfRef}
                        onInput={handleInput}
                        style={{ minWidth: '50px' }}
                    >
                        {content}
                    </math-field>
                    {result && !result.startsWith('Error') && <span style={{ marginLeft: '10px', fontWeight: 'bold' }}>= {result}</span>}
                    {result && result.startsWith('Error') && <span style={{ marginLeft: '10px', color: 'red', fontSize: '0.8em' }}>{result}</span>}
                </div>
            );
        };

        const TextRegion = ({ content, onContentChange }) => {
            return (
                <div className="text-region" style={{ minWidth: '100px' }}>
                    <textarea
                        value={content}
                        onChange={(e) => onContentChange(e.target.value)}
                        placeholder="Type text..."
                        style={{
                            border: 'none',
                            outline: 'none',
                            backgroundColor: 'transparent',
                            resize: 'both',
                            fontFamily: 'Arial, sans-serif',
                            width: '100%',
                            height: '100%'
                        }}
                    />
                </div>
            );
        };

        const Region = ({ id, x, y, children, onMove }) => {
            const [pos, setPos] = useState({ x, y });
            const [dragging, setDragging] = useState(false);
            const [rel, setRel] = useState({ x: 0, y: 0 });

            // Sync props to internal state
            useEffect(() => {
                if (!dragging) {
                    setPos({ x, y });
                }
            }, [x, y, dragging]);

            const onMouseDown = (e) => {
                if (!e.target.classList.contains('handle')) return;
                setDragging(true);
                setRel({ x: e.pageX - pos.x, y: e.pageY - pos.y });
                e.stopPropagation();
                e.preventDefault();
            };

            const onMouseMove = (e) => {
                if (!dragging) return;
                setPos({ x: e.pageX - rel.x, y: e.pageY - rel.y });
                e.stopPropagation();
                e.preventDefault();
            };

            const onMouseUp = (e) => {
                if (dragging) {
                    setDragging(false);
                    onMove(id, pos.x, pos.y);
                }
            };

            useEffect(() => {
                if (dragging) {
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                } else {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }
                return () => document.removeEventListener('mousemove', onMouseMove);
            }, [dragging, pos]);

            return (
                <div
                    style={{
                        position: 'absolute',
                        left: pos.x,
                        top: pos.y,
                        display: 'inline-block',
                        border: '1px solid transparent',
                        padding: '5px',
                        zIndex: dragging ? 1000 : 1
                    }}
                    className="region-container"
                    onMouseDown={onMouseDown}
                >
                    <div className="handle" style={{ height: '10px', cursor: 'move', backgroundColor: 'rgba(0,0,0,0.05)', marginBottom: '2px', display: 'none' }}></div>
                    {children}
                </div>
            );
        };

        const Toolbar = ({ onInsertGlobal }) => {
            return (
                <div className="toolbar">
                    <button onClick={onInsertGlobal} title="Global Definition">Global (â‰¡)</button>
                </div>
            );
        };

        const Canvas = () => {
            const [regions, setRegions] = useState([]);
            const [activeMathField, setActiveMathField] = useState(null);
            const canvasRef = useRef(null);

            const debouncedRegions = useDebounce(regions, 500);

            useEffect(() => {
                const evaluate = async () => {
                    const mathRegions = debouncedRegions.filter(r => r.type === 'math');
                    if (mathRegions.length === 0) return;

                    try {
                        const response = await axios.post('http://localhost:5000/evaluate', {
                            regions: mathRegions
                        });
                        const results = response.data.results;

                        setRegions(prevRegions => {
                            let hasChanged = false;
                            const newRegions = prevRegions.map(r => {
                                if (results[r.id] !== undefined) {
                                    if (r.result !== results[r.id]) {
                                        hasChanged = true;
                                        return { ...r, result: results[r.id] };
                                    }
                                }
                                return r;
                            });

                            // Only update state if results actually changed to prevent infinite loop
                            return hasChanged ? newRegions : prevRegions;
                        });
                    } catch (err) {
                        console.error("Evaluation error", err);
                    }
                };
                evaluate();
            }, [debouncedRegions]);

            const addRegion = (type, x, y) => {
                const newRegion = {
                    id: Date.now().toString(),
                    type,
                    x,
                    y,
                    content: '',
                    result: null
                };
                setRegions([...regions, newRegion]);
            };

            const handleDoubleClick = (e) => {
                if (e.target === canvasRef.current) {
                    const rect = canvasRef.current.getBoundingClientRect();
                    addRegion('math', e.clientX - rect.left, e.clientY - rect.top);
                }
            }

            const handleContextMenu = (e) => {
                e.preventDefault();
                if (e.target === canvasRef.current) {
                    const rect = canvasRef.current.getBoundingClientRect();
                    addRegion('text', e.clientX - rect.left, e.clientY - rect.top);
                }
            }

            const updateRegionContent = (id, newContent) => {
                setRegions(prev => prev.map(r => r.id === id ? { ...r, content: newContent } : r));
            };

            const updateRegionPosition = (id, x, y) => {
                setRegions(prev => prev.map(r => r.id === id ? { ...r, x, y } : r));
            };

            const handleInsertGlobal = () => {
                const activeEl = document.activeElement;
                if (activeEl && activeEl.tagName.toLowerCase() === 'math-field') {
                    activeEl.executeCommand(['insert', '\\equiv']);
                    activeEl.focus();
                }
            };

            return (
                <div style={{ width: '100%', height: '100%' }}>
                    <Toolbar onInsertGlobal={handleInsertGlobal} />
                    <div
                        ref={canvasRef}
                        className="canvas"
                        onDoubleClick={handleDoubleClick}
                        onContextMenu={handleContextMenu}
                    >
                        <div style={{position: 'absolute', top: 50, left: 10, pointerEvents: 'none', color: '#888'}}>
                            Double-click: Math | Right-click: Text | Move regions to change order
                        </div>
                        {regions.map((region) => (
                            <Region
                                key={region.id}
                                id={region.id}
                                x={region.x}
                                y={region.y}
                                onMove={updateRegionPosition}
                            >
                                {region.type === 'math' ? (
                                    <MathRegion
                                        content={region.content}
                                        result={region.result}
                                        onContentChange={(val) => updateRegionContent(region.id, val)}
                                        onFocus={() => {}}
                                    />
                                ) : (
                                    <TextRegion
                                        content={region.content}
                                        onContentChange={(val) => updateRegionContent(region.id, val)}
                                    />
                                )}
                            </Region>
                        ))}
                    </div>
                </div>
            );
        };

        const App = () => {
            return (
                <div className="App">
                    <Canvas />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
